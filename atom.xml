<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://easy-go-ing.github.io</id>
    <title>Easy Going</title>
    <updated>2019-06-13T03:06:58.625Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://easy-go-ing.github.io"/>
    <link rel="self" href="https://easy-go-ing.github.io/atom.xml"/>
    <subtitle>Take it easy !!</subtitle>
    <logo>https://easy-go-ing.github.io/images/avatar.png</logo>
    <icon>https://easy-go-ing.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Easy Going</rights>
    <entry>
        <title type="html"><![CDATA[python string to timestamp & timestamp to string]]></title>
        <id>https://easy-go-ing.github.io/post/python-string-to-timestamp-and-timestamp-to-string</id>
        <link href="https://easy-go-ing.github.io/post/python-string-to-timestamp-and-timestamp-to-string">
        </link>
        <updated>2019-06-13T02:43:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="string-2-timestamp">string 2 timestamp</h3>
<ol>
<li>先将string转换成time_struct</li>
<li>再将time_struct转换成timestamp</li>
</ol>
<h3 id="timestamp-2-string">timestamp 2 string</h3>
<ol>
<li>先将timestamp转换成time_struct</li>
<li>再将time_struct转换成string</li>
</ol>
<p>PS.无论哪种转换，都需要先转换成time_struct</p>
<pre><code class="language-python">import time
def str2timestamp(s,f='%Y%m%d%H%M%S'):
    return int(time.mktime(time.strptime(s,f)))
def timestamp2str(t,f='%Y-%m-%d %H:%M:%S'):
    return time.strftime(f,time.localtime(t))
</code></pre>
<!-- more --> ]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python 离线安装easy_install和pip]]></title>
        <id>https://easy-go-ing.github.io/post/python-chi-xian-an-zhuang-easy_install-he-pip</id>
        <link href="https://easy-go-ing.github.io/post/python-chi-xian-an-zhuang-easy_install-he-pip">
        </link>
        <updated>2019-06-13T02:38:15.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>先安装easy_install
下载源码包:https://pypi.python.org/pypi/ez_setup 解压，安装</li>
</ol>
<pre><code class="language-bash">$ python ez_setup.py
</code></pre>
<ol start="2">
<li>再安装pip
下载源码包:https://pypi.python.org/pypi/pip 解压，安装</li>
</ol>
<pre><code class="language-bash">$ python setup.py install
</code></pre>
<!-- more --> ]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[install c/c++ dev env]]></title>
        <id>https://easy-go-ing.github.io/post/install-cc-dev-env</id>
        <link href="https://easy-go-ing.github.io/post/install-cc-dev-env">
        </link>
        <updated>2019-06-13T02:35:39.000Z</updated>
        <content type="html"><![CDATA[<h4 id="安装gnu的cc开发包和编译器">安装GNU的C/C++开发包和编译器</h4>
<ul>
<li>for: Fedora, Red Hat, CentOS, Scientific Linux</li>
</ul>
<pre><code class="language-bash">$ yum groupinstall 'Development Tools'
</code></pre>
<ul>
<li>for: Debian, Ubuntu Linux</li>
</ul>
<pre><code class="language-bash">$ sudo apt-get update
$ sudo apt-get install build-essential manpages-dev
</code></pre>
<!-- more --> ]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[xml to json & json to xml (just with standard library)]]></title>
        <id>https://easy-go-ing.github.io/post/xml-to-json-and-json-to-xml-just-with-standard-library</id>
        <link href="https://easy-go-ing.github.io/post/xml-to-json-and-json-to-xml-just-with-standard-library">
        </link>
        <updated>2019-06-12T09:33:37.000Z</updated>
        <summary type="html"><![CDATA[<p>摘要：</p>
<ol>
<li>xml to json (python&gt;2.6)</li>
<li>json to xml  (python&gt;2.6)</li>
<li>xml to json (python&gt;2.6, kv in json order by xml)</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<p>摘要：</p>
<ol>
<li>xml to json (python&gt;2.6)</li>
<li>json to xml  (python&gt;2.6)</li>
<li>xml to json (python&gt;2.6, kv in json order by xml)</li>
</ol>
<!-- more -->
<h4 id="xml-to-json-python26">xml to json (python&gt;2.6)</h4>
<ul>
<li>定义转换方法</li>
</ul>
<pre><code class="language-python">from collections import defaultdict

def etree_to_dict(t):
    d = {t.tag: {} if t.attrib else None}
    children = list(t)
    if children:
        dd = defaultdict(list)
        for dc in map(etree_to_dict, children):
            for k, v in dc.items():
                dd[k].append(v)
        d = {t.tag: {k:v[0] if len(v) == 1 else v for k, v in dd.items()}}
    if t.attrib:
        d[t.tag].update(('@' + k, v) for k, v in t.attrib.items())
    if t.text:
        text = t.text.strip()
        if children or t.attrib:
            if text:
              d[t.tag]['#text'] = text
        else:
            d[t.tag] = text
    return d
</code></pre>
<ul>
<li>使用</li>
</ul>
<pre><code class="language-python">from xml.etree import cElementTree as ET
e = ET.XML('''
&lt;root&gt;
  &lt;e /&gt;
  &lt;e&gt;text&lt;/e&gt;
  &lt;e name=&quot;value&quot; /&gt;
  &lt;e name=&quot;value&quot;&gt;text&lt;/e&gt;
  &lt;e&gt; &lt;a&gt;text&lt;/a&gt; &lt;b&gt;text&lt;/b&gt; &lt;/e&gt;
  &lt;e&gt; &lt;a&gt;text&lt;/a&gt; &lt;a&gt;text&lt;/a&gt; &lt;/e&gt;
  &lt;e&gt; text &lt;a&gt;text&lt;/a&gt; &lt;/e&gt;
&lt;/root&gt;
''')

from pprint import pprint
pprint(etree_to_dict(e))
</code></pre>
<ul>
<li>输出</li>
</ul>
<pre><code class="language-python">{'root': {'e': [None,
                'text',
                {'@name': 'value'},
                {'#text': 'text', '@name': 'value'},
                {'a': 'text', 'b': 'text'},
                {'a': ['text', 'text']},
                {'#text': 'text', 'a': 'text'}]}}
</code></pre>
<h4 id="json-to-xml-python26">json to xml  (python&gt;2.6)</h4>
<ul>
<li>定义转换方法</li>
</ul>
<pre><code class="language-python">try:
  basestring
except NameError:  # python3
  basestring = str

def dict_to_etree(d):
    def _to_etree(d, root):
        if not d:
            pass
        elif isinstance(d, basestring):
            root.text = d
        elif isinstance(d, dict):
            for k,v in d.items():
                assert isinstance(k, basestring)
                if k.startswith('#'):
                    assert k == '#text' and isinstance(v, basestring)
                    root.text = v
                elif k.startswith('@'):
                    assert isinstance(v, basestring)
                    root.set(k[1:], v)
                elif isinstance(v, list):
                    for e in v:
                        _to_etree(e, ET.SubElement(root, k))
                else:
                    _to_etree(v, ET.SubElement(root, k))
        else:
            raise TypeError('invalid type: ' + str(type(d)))
    assert isinstance(d, dict) and len(d) == 1
    tag, body = next(iter(d.items()))
    node = ET.Element(tag)
    _to_etree(body, node)
    return ET.tostring(node)

pprint(dict_to_etree(d))
</code></pre>
<h4 id="xml-to-json-python26-kv-in-json-order-by-xml">xml to json (python&gt;2.6, kv in json order by xml)</h4>
<ul>
<li>定义转换方法</li>
</ul>
<pre><code class="language-python">def etree_to_ordereddict(t):
	d = OrderedDict()
	d[t.tag] = OrderedDict() if t.attrib else None
	children = list(t)
	if children:
	    dd = OrderedDict()
	    for dc in map(etree_to_ordereddict, children):
	        for k, v in dc.iteritems():
	            if k not in dd:
	                dd[k] = list()
	            dd[k].append(v)
	    d = OrderedDict()
	    d[t.tag] = OrderedDict()
	    for k, v in dd.iteritems():
	        if len(v) == 1:
	            d[t.tag][k] = v[0]
	        else:
	            d[t.tag][k] = v
	if t.attrib:
	    d[t.tag].update(('@' + k, v) for k, v in t.attrib.iteritems())
	if t.text:
	    text = t.text.strip()
	    if children or t.attrib:
	        if text:
	            d[t.tag]['#text'] = text
	    else:
	        d[t.tag] = text
	return d
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sort sort by mul field]]></title>
        <id>https://easy-go-ing.github.io/post/sort-sort-by-mul-field</id>
        <link href="https://easy-go-ing.github.io/post/sort-sort-by-mul-field">
        </link>
        <updated>2019-06-12T09:23:17.000Z</updated>
        <content type="html"><![CDATA[<p>多字段排序：
以:为分隔符，对第3字段以数字方式，第6字段以数字方式排序</p>
<pre><code class="language-bash">$ sort -t: +2n -3 +5n -6
</code></pre>
<p>说明：</p>
<p>指定第m个字段的方法是： +(m-1) -m
字段后跟n表示数字序,r表示倒序
根据第1字段默认，第5字段倒序进行排序</p>
<pre><code class="language-bash">$ sort +0 -1 +4nr -5 d
</code></pre>
<!-- more -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sort tab]]></title>
        <id>https://easy-go-ing.github.io/post/sort-tab</id>
        <link href="https://easy-go-ing.github.io/post/sort-tab">
        </link>
        <updated>2019-06-12T09:05:02.000Z</updated>
        <content type="html"><![CDATA[<p>指定tab为分隔符，tab的输入</p>
<pre><code class="language-bash">$ sort -t '&lt;tab&gt;'  # tab的输入方法：Ctrl-v-i
$ sort -t $'\t' inputfile -o outfile  # 也可以用$'&lt;backslash-code&gt;'语法
</code></pre>
<!-- more -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[find more path in one command]]></title>
        <id>https://easy-go-ing.github.io/post/find-more-path-in-one-command</id>
        <link href="https://easy-go-ing.github.io/post/find-more-path-in-one-command">
        </link>
        <updated>2019-06-12T08:40:35.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-bash">$ find /path1 /path2 -type f -name &quot;*&quot;
</code></pre>
<!-- more --> ]]></content>
    </entry>
</feed>